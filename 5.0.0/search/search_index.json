{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What's OpenVeo Plugin Generator? OpenVeo Plugin Generator is a Yeoman plugin generator for OpenVeo used to improve OpenVeo plugin development. It helps you create a plugin ready for development with: Full operational grunt tasks for: unit testing server and client sides compiling JavaScript and CSS for client side generating code documentation (using YUI ) generating markdown documentation (using MkDocs ) A basic back end page example with internationalization Default plugin files with minimum configuration","title":"INTRODUCTION"},{"location":"#whats-openveo-plugin-generator","text":"OpenVeo Plugin Generator is a Yeoman plugin generator for OpenVeo used to improve OpenVeo plugin development. It helps you create a plugin ready for development with: Full operational grunt tasks for: unit testing server and client sides compiling JavaScript and CSS for client side generating code documentation (using YUI ) generating markdown documentation (using MkDocs ) A basic back end page example with internationalization Default plugin files with minimum configuration","title":"What's OpenVeo Plugin Generator?"},{"location":"back-end/","text":"Introduction OpenVeo back end is an AngularJS single page application served on /be . That's why OpenVeo Plugins must write their back end pages using AngularJS whereas there is no restriction on front end pages implementation. As you can see in the generated plugin, an AngularJS module is already written, thus all you have to do is to write new routes and implement your custom back end pages. OpenVeo core offers some features as factories, services, filters and directives that you can use to ease your plugin's development. See OpenVeo core documentation for more details. Add a back end page Let's pretend we want to add a new back end page to a library plugin. Configure back end menu As described in conf.js documentation you can add a page to the back end. Open conf.js file and add a new back end page. backOffice: { menu: [ { weight: -50, label: 'Library', subMenu: [ { label: 'Book info', path: 'library/bookInfo', permission: 'library-access-book-page' } ] } ] } We defined a new menu entry for our plugin with Library as a label and a sub menu with one item named Book info which requires library-access-book-page permission to see the page. For now there is nothing being the AngularJS route library/bookInfo . Let's create the route. Add an AngularJS back end route As OpenVeo back end is written in AngularJS, each plugin has an AngularJS module to create its back end pages. Open file app/client/admin/js/ovLibrary/BookApp.js . You can see the AngularJS module corresponding to the plugin. Add the new route: // Add route /library/bookInfo $routeProvider.when('/library/bookInfo', { templateUrl: '/library/be/views/bookInfo.html', controller: 'LibraryBookController', title: 'Book page title', access: 'library-access-book-page', resolve: { book: ['$q', function($q) { var p = $q.defer(); p.resolve({ title: 'Journey to the center of the earth', summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson ( Heimskringla ; the chronicle of the Norwegian kings who ruled over Iceland).' }); return p.promise; }] } }); We defined a new route /library/bookInfo with a template, a controller, a page title and a permission to access the page. Let's create the controller and the template. Add back end page controller Create a file app/client/admin/js/ovLibrary/BookController.js : 'use strict'; (function(app) { /** * Defines a book controller. */ function BookController($scope, book) { $scope.title = book.title; $scope.summary = book.summary; } app.controller('LibraryBookController', BookController); BookController.$inject = ['$scope', 'book']; })(angular.module('ov.library')); Open conf.js file and add the newly created file to the list of files to be loaded by OpenVeo: backOffice: { scriptFiles: { base: [], dev: [ 'ovLibrary/BookController.js' ] } } Add back end page template Create a file assert/be/views/bookInfo.html : h1 ng-bind= title /h1 p ng-bind= summary /p","title":"Back end AngularJS"},{"location":"back-end/#introduction","text":"OpenVeo back end is an AngularJS single page application served on /be . That's why OpenVeo Plugins must write their back end pages using AngularJS whereas there is no restriction on front end pages implementation. As you can see in the generated plugin, an AngularJS module is already written, thus all you have to do is to write new routes and implement your custom back end pages. OpenVeo core offers some features as factories, services, filters and directives that you can use to ease your plugin's development. See OpenVeo core documentation for more details.","title":"Introduction"},{"location":"back-end/#add-a-back-end-page","text":"Let's pretend we want to add a new back end page to a library plugin.","title":"Add a back end page"},{"location":"back-end/#configure-back-end-menu","text":"As described in conf.js documentation you can add a page to the back end. Open conf.js file and add a new back end page. backOffice: { menu: [ { weight: -50, label: 'Library', subMenu: [ { label: 'Book info', path: 'library/bookInfo', permission: 'library-access-book-page' } ] } ] } We defined a new menu entry for our plugin with Library as a label and a sub menu with one item named Book info which requires library-access-book-page permission to see the page. For now there is nothing being the AngularJS route library/bookInfo . Let's create the route.","title":"Configure back end menu"},{"location":"back-end/#add-an-angularjs-back-end-route","text":"As OpenVeo back end is written in AngularJS, each plugin has an AngularJS module to create its back end pages. Open file app/client/admin/js/ovLibrary/BookApp.js . You can see the AngularJS module corresponding to the plugin. Add the new route: // Add route /library/bookInfo $routeProvider.when('/library/bookInfo', { templateUrl: '/library/be/views/bookInfo.html', controller: 'LibraryBookController', title: 'Book page title', access: 'library-access-book-page', resolve: { book: ['$q', function($q) { var p = $q.defer(); p.resolve({ title: 'Journey to the center of the earth', summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson ( Heimskringla ; the chronicle of the Norwegian kings who ruled over Iceland).' }); return p.promise; }] } }); We defined a new route /library/bookInfo with a template, a controller, a page title and a permission to access the page. Let's create the controller and the template.","title":"Add an AngularJS back end route"},{"location":"back-end/#add-back-end-page-controller","text":"Create a file app/client/admin/js/ovLibrary/BookController.js : 'use strict'; (function(app) { /** * Defines a book controller. */ function BookController($scope, book) { $scope.title = book.title; $scope.summary = book.summary; } app.controller('LibraryBookController', BookController); BookController.$inject = ['$scope', 'book']; })(angular.module('ov.library')); Open conf.js file and add the newly created file to the list of files to be loaded by OpenVeo: backOffice: { scriptFiles: { base: [], dev: [ 'ovLibrary/BookController.js' ] } }","title":"Add back end page controller"},{"location":"back-end/#add-back-end-page-template","text":"Create a file assert/be/views/bookInfo.html : h1 ng-bind= title /h1 p ng-bind= summary /p","title":"Add back end page template"},{"location":"coding-standards/","text":"Plugins should respect OpenVeo coding standards based on Node.js coding standards. ESLint is used to validate coding rules. You can launch a code verification using the following command: grunt eslint Nb: Both Node.js and AngularJS parts of the plugin must respect the same coding standards","title":"Coding standards"},{"location":"compilation/","text":"Introduction Plugin's back end pages are written using AngularJS and SASS / Compass. SASS files need to be compiled to generate the CSS and JavaScript files can be minified and aggregated for better performance. Compiling SASS files You can compile the back end SASS files using the following command: grunt compass:dist Or you can watch SASS files changes using the following command: grunt Compiling JavaScript files You'll probably want to compile AngularJS files, in production, for better performance. You can do it using: grunt prod","title":"CSS / SASS / JS compilation"},{"location":"compilation/#introduction","text":"Plugin's back end pages are written using AngularJS and SASS / Compass. SASS files need to be compiled to generate the CSS and JavaScript files can be minified and aggregated for better performance.","title":"Introduction"},{"location":"compilation/#compiling-sass-files","text":"You can compile the back end SASS files using the following command: grunt compass:dist Or you can watch SASS files changes using the following command: grunt","title":"Compiling SASS files"},{"location":"compilation/#compiling-javascript-files","text":"You'll probably want to compile AngularJS files, in production, for better performance. You can do it using: grunt prod","title":"Compiling JavaScript files"},{"location":"conf/","text":"Introduction A consequent part of the development of plugins is made in conf.js file at plugin's root. conf.js is used to: Map HTTP routes on actions Create entities Define back end permissions Define back end menu items Load back end scripts Load back end CSS Set the list of directories containing templates Define image styles Define Web Service scopes Define socket namespaces Define custom configuration Map HTTP routes on actions HTTP routes are separated into three categories : public, private and Web Service routes. http: { routes: { public: { [...] }, private: { [...] }, ws: { [...] } } } Route descriptor A route maps an HTTP method and a path to an action (JavaScript function). The route: 'get /test' : 'app/server/controllers/TestController.testGetAction' Can be interpreted as: A GET request on /test will call the function testGetAction exposed by module app/server/controllers/TestController.js The route: 'post /test' : 'app/server/controllers/TestController.testPostAction' Can be interpreted as: A POST request on /test will call the function testPostAction exposed by module app/server/controllers/TestController.js The route: '/test' : 'app/server/controllers/TestController.testAllAction' Can be interpreted as: All requests on /test (GET, POST, DELETE, PUT) will call the function testAllAction exposed by module app/server/controllers/TestController.js Example of valid routes: http: { routes: { public: { 'get /test': 'TestController.getTestAction', 'post /test': 'TestController.postTestAction', 'put /test': 'TestController.putTestAction', '/test': 'TestController.allTestAction' } } } Group routes You can group actions by routes: http: { routes: { public: { '*': [ 'TestController.allFirstAction', 'TestController.allSecondAction' ] } } } Route parameters You can add parameters using colon character: http: { routes: { public: { 'DELETE /test/:id': 'TestController.deleteTestAction' } } } Create TestController 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); /** * Creates a TestController. */ function TestController() { TestController.super_.call(this); } module.exports = TestController; util.inherits(TestController, openVeoApi.controllers.Controller); /** * Defines an example action. * * @param {Object} request Express HTTP request * @param {Object} response Express HTTP response * @param {Function} next Express next function to move on the next middleware */ TestController.prototype.exampleAction = function(request, response, next) { response.status(200).send('ok'); }; Define socket namespaces Socket namespaces are mounted on the OpenVeo Socket server to listen to Socket messages. Create a socket namespace You can define new namespaces for the Socket server in conf.js . Namespaces are separated into two categories: public and private namespaces. Let's pretend we want to create a public and a private namespace for a library plugin. socket: { namespaces: { public: { // Public namespaces can be accessed by anyone 'public-namespace': { [...] // Namespace messages descriptors } }, private: { // Private namespaces require a back end authentication 'private-namespace': { [...] // Namespace messages descriptors } } } } Message descriptor A socket message maps a message to an action (JavaScript function). The message: 'my.test.message' : 'app/server/controllers/TestController.testMessageAction' Can be interpreted as: A socket message 'my.test.message' will call the function testMessageAction exposed by module app/server/controllers/TestSocketController.js The following messages are automatically sent by the socket server and does not need to be send by the socket client: connection Client is connected to the socket server disconnect Client has been disconnected from the socket server error An error occurred in client / server connection Let's pretend we want to handle the default messages and custom messages in our public-namespace namespace: 'public-namespace': { connection: 'app/server/controllers/TestSocketController.connectAction', disconnect: 'app/server/controllers/TestSocketController.disconnectAction', error: 'app/server/controllers/TestSocketController.errorAction', customMessage1: 'app/server/controllers/TestSocketController.customMessage1Action', customMessage2: 'app/server/controllers/TestSocketController.customMessage2Action' } Create TestSocketController Create a file app/server/controllers/TestSocketController.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); var coreApi = process.api.getCoreApi(); /** * Creates a TestSocketController. * * @param {SocketNamespace} The namespace associated to this socket controller. */ function TestSocketController(namespace) { TestSocketController.super_.call(this, namespace); } module.exports = TestSocketController; util.inherits(TestSocketController, openVeoApi.controllers.SocketController); /** * Handles socket's connection. * * Socket's connection has been established with a client. * * @method connectAction * @param {Socket} socket The socket */ TestSocketController.prototype.connectAction = function(socket) { console.log('Client connected'); }; /** * Handles socket's disconnection. * * Connection with client has been lost. * * @method disconnectAction * @param {Socket} socket The socket */ TestSocketController.prototype.disconnectAction = function(socket) { console.log('Client disconnected'); }; /** * Handles socket's connection errors. * * An error occurred on socket's communication. * * @method errorAction * @param {Error} error The error * @param {Socket} socket The socket */ TestSocketController.prototype.errorAction = function(error, socket) { console.log(error); }; /** * Defines customMessage1 action. * * @param {Object} data Socket message's datas * @param {Socket} socket The opened socket * @param {Function} callback The callback to respond to the client */ TestSocketController.prototype.customMessage1Action = function(data, socket, callback) { // Send a response to the client callback({ property1: 'value1' }); }; /** * Defines customMessage2 action. * * @param {Object} data Socket message's datas * @param {Socket} socket The opened socket * @param {Function} callback The callback to respond to the client */ TestSocketController.prototype.customMessage2Action = function(data, socket, callback) { // Send a message on all namespace's clients this.namespace.emit('test.response', { property2: 'value2' }); }; Use socket namespace We created a socket namespace public-namespace for the library plugin. Namespace is now available on the socket server and is mounted on /library/public-namespace . All socket messages sent to this namespace will be routed to actions defined in conf.js file. Create entities Entities are elements subject to CRUD ( C reate R ead U pdate D elete). For example, OpenVeo core defines 5 entities: applications - Web Service client applications users - Back end users roles - Back end roles groups - Groups taxonomies - Taxonomies with associated terms Each entity will automatically have 3 associated back end permissions : add, update and delete. To create a new entity you need to create an EntityController and an EntityProvider. Let's say we want to create a new entity called books on a plugin named library . Create entity provider Create a file app/server/providers/BooksProvider.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); /** * Creates a BooksProvider. */ function BooksProvider(database) { BooksProvider.super_.call(this, database, 'library_books'); } // BookProvider must extend EntityProvider module.exports = BooksProvider; util.inherits(BooksProvider, openVeoApi.providers.EntityProvider); Create entity controller Create a file app/server/controllers/BooksController.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); var BooksProvider = process.requireBook('app/server/providers/BooksProvider.js'); /** * Creates a BooksController. */ function BooksController(database) { BooksController.super_.call(this); } module.exports = BooksController; util.inherits(BooksController, openVeoApi.controllers.EntityController); /** * Gets an instance of the BooksProvider. * * @method getProvider * @return {BooksProvider} The BooksProvider instance */ BooksController.prototype.getProvider = function() { var database = process.api.getCoreApi().getDatabase(); return new BooksProvider(database); }; Declare entity You can now declare your entity in conf.js : entities: { books: 'app/server/controllers/BooksController' } Use the entity Now that your entity books is created you can see the 3 new permissions in the back end (add, update and delete). You can also perform CRUD operations on your entity using the following private routes (with a user connected to the back end): get /be/library/books/:id - Get a particular book get /be/library/books - Get all books post /be/library/books/:id - Update a particular book put /be/library/books - Add a new book delete /be/library/books/:id - Delete a book Finally you can perform CRUD operations on your entity using the Web Service (with a user connected to the Web Service) using the following end points: get /library/books/:id - Get a particular book get /library/books - Get all books post /library/books/:id - Update a particular book put /library/books - Add a new book delete /library/books/:id - Delete a book Define back end permissions Each role can have n associated permissions. Permissions are described in conf.js : permissions: [ [...] ] Create a permission Let's create new permissions \"sell\" and \"buy\" to sell / buy books. permissions: [ { id: 'library-sell-books', // Permission id name: 'Sell', // Permission name description: 'Sell books', // Permission description paths: [ // List of rules associated to the permission 'get /library/books/:id/sell' ] }, { id: 'library-buy-books', // Permission id name: 'Buy', // Permission name description: 'Buy books', // Permission description paths: [ // List of rules associated to the permission 'get /library/books/:id/buy' ] } ] A permission is defined by: an id which must be unique and prefix by the name of your plugin a name displayed in OpenVeo administration interface when listing permissions (it could be a translation id) a description not actually used (it could be a translation id) a list of rules this permission authorizes. In the above example, a user with permission Sell can perform requests on route get /library/books/25/sell . It uses a parameter ( :id ) to match routes containing dynamic parts. It is also possible to use a wildcard at the end of the rule like /library/books/ * Group permissions You can group permissions to organize the list of permissions in the back end. Nb : Actually OpenVeo only supports one sub level permissions: [ { label: 'Library', // Group label permissions: [ // List of permission in the group { id: 'library-sell-books', name: 'Sell', description: 'Sell books', paths: [ 'get /library/books/:id/sell' ] }, { id: 'library-buy-books', name: 'Buy', description: 'Buy books', paths: [ 'get /library/books/:id/buy' ] } ] } ] Use permissions You can assign your permission to a role through the back end or manipulate the permission using back end client (AngularJS application). Define back end menu items Back end menu items are described in conf.js : backOffice: { menu: [ [...] ] } Add a menu item Let's create two new back end menu items. backOffice: { menu: [ { weight: -5, label: 'Sell books', // Menu item name path: 'library/books/sell-books', // Menu item path permission: 'library-sell-books' // Menu item associated permission }, { weight: -6, label: 'Buy books', // Menu item name path: 'library/books/buy-books', // Menu item path permission: 'library-buy-books' // Menu item associated permission } ] } weight property helps order menu items, the larger the weight is, the better will be the item position. path defines the AngularJS root path (see back end client ) permission associates a permission to the menu item, if the connected user doesn't have that permission the item won't be displayed Group menu items You can group menu items as sub menu items. Nb : Actually OpenVeo only supports one sub level of menu items backOffice: { menu: [ { weight: 100, // Position of the item in the menu label: 'Books', // Name of the menu item subMenu: [ // List of sub menu items { label: 'Sell books', path: 'library/books/sell-books', permission: 'library-sell-books' }, { label: 'Buy books', path: 'library/books/buy-books', permission: 'book-buy-books' } ] } ] } Libraries The list of libraries to load are defined in conf.js : libraries: [ { // The name of the library as defined in package.json file name: 'angular', // The mount path to use to access the library, it will be automatically prefixed by the plugin mount path mountPath: 'angular-custom-mount-path', // The list of files to automatically load in the back office with paths relative to the library directory // Library will still be mounted even if there is no files to automatically load in the back office files: ['angular.min.js', 'angular-csp.css'] }, [...] ] Nb: library files are loaded before the back end scripts below Back end scripts The list of JavaScript files to load for the AngularJS back end application are defined in conf.js : backOffice: { scriptLibFiles: { // List of back end JavaScript files to load first dev: [ // List of scripts to load on development environment [...] ], prod: [ // List of script to load on production environment [...] ] }, scriptFiles: { // List of back end JavaScript files to load next dev: [ // List of scripts to load on development environment [...] ], prod: [ // List of script to load on production environment [...] ] } } Back end CSS The list of CSS files to load for the AngularJS back end application are defined in conf.js : backOffice: { cssFiles: [ // List of CSS to load [...] ] } List of directories containing templates OpenVeo uses Mustache as the template engine. Mustache requires directories where to look for potential templates. The list of directories is defined in conf.js : viewsFolders: [ // List of directories holding mustache templates [...] ] Define image styles You can define image styles in conf.js : imageProcessing: { folders: [ // List of folders which contain images to process on demand { imagesDirectory: 'example/images', // Path of the directory containing images to process relative to project root directory cacheDirectory: 'example/images/.cache' // Path of the directory containing processed images relative to project root directory (default to {imagesDirectory}/.cache) } ], styles: [ // The list of style definitions { id: 'book-style', // Id of the style to apply when requesting an image processing type: 'thumb', // The type of transformation to apply (only thumb is available right now) width: 200, // Expected width (in px) of the image (default to 10) quality: 50 // Expected quality from 0 to 100 (default to 90 with 100 the best) } } } Then you can call the image with your custom style book-style : img src= book/example/images/image1.jpg?style=book-style / Note that the original image is still available: img src= book/example/images/image1.jpg / Define custom configuration You can define a custom configuration object in conf.js : custom: { customProperty1: 'customValue1', customProperty2: 2 } Nb: Custom configuration won't be interpreted but can be retrieved later using OpenVeo API. You can use it as you like. Define web service scopes You can define web service scopes in conf.js : webServiceScopes: [ { id: 'library-scopeId', name: 'Scope name', description: 'Scope description', paths: [ 'get /library/books/sell', 'get /library/books/buy' ] } ] A scope is defined by: an id which must be unique and prefix by the name of your plugin a name displayed in OpenVeo administration interface when listing scopes (it could be a translation id) a description not actually used (it could be a translation id) a list of rules this scope authorizes. In the above example, a client application with scope Scope name can perform requests on two endpoints: get /library/books/sell and get /library/books/buy . Both endpoints could have been grouped into one rule get /library/books/ . It is also possible to deal with paths containing dynamic parts like *get /library/books/25/sell using a rule with a parameter: get /library/books/:id/sell**","title":"conf.js"},{"location":"conf/#introduction","text":"A consequent part of the development of plugins is made in conf.js file at plugin's root. conf.js is used to: Map HTTP routes on actions Create entities Define back end permissions Define back end menu items Load back end scripts Load back end CSS Set the list of directories containing templates Define image styles Define Web Service scopes Define socket namespaces Define custom configuration","title":"Introduction"},{"location":"conf/#map-http-routes-on-actions","text":"HTTP routes are separated into three categories : public, private and Web Service routes. http: { routes: { public: { [...] }, private: { [...] }, ws: { [...] } } }","title":"Map HTTP routes on actions"},{"location":"conf/#route-descriptor","text":"A route maps an HTTP method and a path to an action (JavaScript function). The route: 'get /test' : 'app/server/controllers/TestController.testGetAction' Can be interpreted as: A GET request on /test will call the function testGetAction exposed by module app/server/controllers/TestController.js The route: 'post /test' : 'app/server/controllers/TestController.testPostAction' Can be interpreted as: A POST request on /test will call the function testPostAction exposed by module app/server/controllers/TestController.js The route: '/test' : 'app/server/controllers/TestController.testAllAction' Can be interpreted as: All requests on /test (GET, POST, DELETE, PUT) will call the function testAllAction exposed by module app/server/controllers/TestController.js Example of valid routes: http: { routes: { public: { 'get /test': 'TestController.getTestAction', 'post /test': 'TestController.postTestAction', 'put /test': 'TestController.putTestAction', '/test': 'TestController.allTestAction' } } }","title":"Route descriptor"},{"location":"conf/#group-routes","text":"You can group actions by routes: http: { routes: { public: { '*': [ 'TestController.allFirstAction', 'TestController.allSecondAction' ] } } }","title":"Group routes"},{"location":"conf/#route-parameters","text":"You can add parameters using colon character: http: { routes: { public: { 'DELETE /test/:id': 'TestController.deleteTestAction' } } }","title":"Route parameters"},{"location":"conf/#create-testcontroller","text":"'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); /** * Creates a TestController. */ function TestController() { TestController.super_.call(this); } module.exports = TestController; util.inherits(TestController, openVeoApi.controllers.Controller); /** * Defines an example action. * * @param {Object} request Express HTTP request * @param {Object} response Express HTTP response * @param {Function} next Express next function to move on the next middleware */ TestController.prototype.exampleAction = function(request, response, next) { response.status(200).send('ok'); };","title":"Create TestController"},{"location":"conf/#define-socket-namespaces","text":"Socket namespaces are mounted on the OpenVeo Socket server to listen to Socket messages.","title":"Define socket namespaces"},{"location":"conf/#create-a-socket-namespace","text":"You can define new namespaces for the Socket server in conf.js . Namespaces are separated into two categories: public and private namespaces. Let's pretend we want to create a public and a private namespace for a library plugin. socket: { namespaces: { public: { // Public namespaces can be accessed by anyone 'public-namespace': { [...] // Namespace messages descriptors } }, private: { // Private namespaces require a back end authentication 'private-namespace': { [...] // Namespace messages descriptors } } } }","title":"Create a socket namespace"},{"location":"conf/#message-descriptor","text":"A socket message maps a message to an action (JavaScript function). The message: 'my.test.message' : 'app/server/controllers/TestController.testMessageAction' Can be interpreted as: A socket message 'my.test.message' will call the function testMessageAction exposed by module app/server/controllers/TestSocketController.js The following messages are automatically sent by the socket server and does not need to be send by the socket client: connection Client is connected to the socket server disconnect Client has been disconnected from the socket server error An error occurred in client / server connection Let's pretend we want to handle the default messages and custom messages in our public-namespace namespace: 'public-namespace': { connection: 'app/server/controllers/TestSocketController.connectAction', disconnect: 'app/server/controllers/TestSocketController.disconnectAction', error: 'app/server/controllers/TestSocketController.errorAction', customMessage1: 'app/server/controllers/TestSocketController.customMessage1Action', customMessage2: 'app/server/controllers/TestSocketController.customMessage2Action' }","title":"Message descriptor"},{"location":"conf/#create-testsocketcontroller","text":"Create a file app/server/controllers/TestSocketController.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); var coreApi = process.api.getCoreApi(); /** * Creates a TestSocketController. * * @param {SocketNamespace} The namespace associated to this socket controller. */ function TestSocketController(namespace) { TestSocketController.super_.call(this, namespace); } module.exports = TestSocketController; util.inherits(TestSocketController, openVeoApi.controllers.SocketController); /** * Handles socket's connection. * * Socket's connection has been established with a client. * * @method connectAction * @param {Socket} socket The socket */ TestSocketController.prototype.connectAction = function(socket) { console.log('Client connected'); }; /** * Handles socket's disconnection. * * Connection with client has been lost. * * @method disconnectAction * @param {Socket} socket The socket */ TestSocketController.prototype.disconnectAction = function(socket) { console.log('Client disconnected'); }; /** * Handles socket's connection errors. * * An error occurred on socket's communication. * * @method errorAction * @param {Error} error The error * @param {Socket} socket The socket */ TestSocketController.prototype.errorAction = function(error, socket) { console.log(error); }; /** * Defines customMessage1 action. * * @param {Object} data Socket message's datas * @param {Socket} socket The opened socket * @param {Function} callback The callback to respond to the client */ TestSocketController.prototype.customMessage1Action = function(data, socket, callback) { // Send a response to the client callback({ property1: 'value1' }); }; /** * Defines customMessage2 action. * * @param {Object} data Socket message's datas * @param {Socket} socket The opened socket * @param {Function} callback The callback to respond to the client */ TestSocketController.prototype.customMessage2Action = function(data, socket, callback) { // Send a message on all namespace's clients this.namespace.emit('test.response', { property2: 'value2' }); };","title":"Create TestSocketController"},{"location":"conf/#use-socket-namespace","text":"We created a socket namespace public-namespace for the library plugin. Namespace is now available on the socket server and is mounted on /library/public-namespace . All socket messages sent to this namespace will be routed to actions defined in conf.js file.","title":"Use socket namespace"},{"location":"conf/#create-entities","text":"Entities are elements subject to CRUD ( C reate R ead U pdate D elete). For example, OpenVeo core defines 5 entities: applications - Web Service client applications users - Back end users roles - Back end roles groups - Groups taxonomies - Taxonomies with associated terms Each entity will automatically have 3 associated back end permissions : add, update and delete. To create a new entity you need to create an EntityController and an EntityProvider. Let's say we want to create a new entity called books on a plugin named library .","title":"Create entities"},{"location":"conf/#create-entity-provider","text":"Create a file app/server/providers/BooksProvider.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); /** * Creates a BooksProvider. */ function BooksProvider(database) { BooksProvider.super_.call(this, database, 'library_books'); } // BookProvider must extend EntityProvider module.exports = BooksProvider; util.inherits(BooksProvider, openVeoApi.providers.EntityProvider);","title":"Create entity provider"},{"location":"conf/#create-entity-controller","text":"Create a file app/server/controllers/BooksController.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); var BooksProvider = process.requireBook('app/server/providers/BooksProvider.js'); /** * Creates a BooksController. */ function BooksController(database) { BooksController.super_.call(this); } module.exports = BooksController; util.inherits(BooksController, openVeoApi.controllers.EntityController); /** * Gets an instance of the BooksProvider. * * @method getProvider * @return {BooksProvider} The BooksProvider instance */ BooksController.prototype.getProvider = function() { var database = process.api.getCoreApi().getDatabase(); return new BooksProvider(database); };","title":"Create entity controller"},{"location":"conf/#declare-entity","text":"You can now declare your entity in conf.js : entities: { books: 'app/server/controllers/BooksController' }","title":"Declare entity"},{"location":"conf/#use-the-entity","text":"Now that your entity books is created you can see the 3 new permissions in the back end (add, update and delete). You can also perform CRUD operations on your entity using the following private routes (with a user connected to the back end): get /be/library/books/:id - Get a particular book get /be/library/books - Get all books post /be/library/books/:id - Update a particular book put /be/library/books - Add a new book delete /be/library/books/:id - Delete a book Finally you can perform CRUD operations on your entity using the Web Service (with a user connected to the Web Service) using the following end points: get /library/books/:id - Get a particular book get /library/books - Get all books post /library/books/:id - Update a particular book put /library/books - Add a new book delete /library/books/:id - Delete a book","title":"Use the entity"},{"location":"conf/#define-back-end-permissions","text":"Each role can have n associated permissions. Permissions are described in conf.js : permissions: [ [...] ]","title":"Define back end permissions"},{"location":"conf/#create-a-permission","text":"Let's create new permissions \"sell\" and \"buy\" to sell / buy books. permissions: [ { id: 'library-sell-books', // Permission id name: 'Sell', // Permission name description: 'Sell books', // Permission description paths: [ // List of rules associated to the permission 'get /library/books/:id/sell' ] }, { id: 'library-buy-books', // Permission id name: 'Buy', // Permission name description: 'Buy books', // Permission description paths: [ // List of rules associated to the permission 'get /library/books/:id/buy' ] } ] A permission is defined by: an id which must be unique and prefix by the name of your plugin a name displayed in OpenVeo administration interface when listing permissions (it could be a translation id) a description not actually used (it could be a translation id) a list of rules this permission authorizes. In the above example, a user with permission Sell can perform requests on route get /library/books/25/sell . It uses a parameter ( :id ) to match routes containing dynamic parts. It is also possible to use a wildcard at the end of the rule like /library/books/ *","title":"Create a permission"},{"location":"conf/#group-permissions","text":"You can group permissions to organize the list of permissions in the back end. Nb : Actually OpenVeo only supports one sub level permissions: [ { label: 'Library', // Group label permissions: [ // List of permission in the group { id: 'library-sell-books', name: 'Sell', description: 'Sell books', paths: [ 'get /library/books/:id/sell' ] }, { id: 'library-buy-books', name: 'Buy', description: 'Buy books', paths: [ 'get /library/books/:id/buy' ] } ] } ]","title":"Group permissions"},{"location":"conf/#use-permissions","text":"You can assign your permission to a role through the back end or manipulate the permission using back end client (AngularJS application).","title":"Use permissions"},{"location":"conf/#define-back-end-menu-items","text":"Back end menu items are described in conf.js : backOffice: { menu: [ [...] ] }","title":"Define back end menu items"},{"location":"conf/#add-a-menu-item","text":"Let's create two new back end menu items. backOffice: { menu: [ { weight: -5, label: 'Sell books', // Menu item name path: 'library/books/sell-books', // Menu item path permission: 'library-sell-books' // Menu item associated permission }, { weight: -6, label: 'Buy books', // Menu item name path: 'library/books/buy-books', // Menu item path permission: 'library-buy-books' // Menu item associated permission } ] } weight property helps order menu items, the larger the weight is, the better will be the item position. path defines the AngularJS root path (see back end client ) permission associates a permission to the menu item, if the connected user doesn't have that permission the item won't be displayed","title":"Add a menu item"},{"location":"conf/#group-menu-items","text":"You can group menu items as sub menu items. Nb : Actually OpenVeo only supports one sub level of menu items backOffice: { menu: [ { weight: 100, // Position of the item in the menu label: 'Books', // Name of the menu item subMenu: [ // List of sub menu items { label: 'Sell books', path: 'library/books/sell-books', permission: 'library-sell-books' }, { label: 'Buy books', path: 'library/books/buy-books', permission: 'book-buy-books' } ] } ] }","title":"Group menu items"},{"location":"conf/#libraries","text":"The list of libraries to load are defined in conf.js : libraries: [ { // The name of the library as defined in package.json file name: 'angular', // The mount path to use to access the library, it will be automatically prefixed by the plugin mount path mountPath: 'angular-custom-mount-path', // The list of files to automatically load in the back office with paths relative to the library directory // Library will still be mounted even if there is no files to automatically load in the back office files: ['angular.min.js', 'angular-csp.css'] }, [...] ] Nb: library files are loaded before the back end scripts below","title":"Libraries"},{"location":"conf/#back-end-scripts","text":"The list of JavaScript files to load for the AngularJS back end application are defined in conf.js : backOffice: { scriptLibFiles: { // List of back end JavaScript files to load first dev: [ // List of scripts to load on development environment [...] ], prod: [ // List of script to load on production environment [...] ] }, scriptFiles: { // List of back end JavaScript files to load next dev: [ // List of scripts to load on development environment [...] ], prod: [ // List of script to load on production environment [...] ] } }","title":"Back end scripts"},{"location":"conf/#back-end-css","text":"The list of CSS files to load for the AngularJS back end application are defined in conf.js : backOffice: { cssFiles: [ // List of CSS to load [...] ] }","title":"Back end CSS"},{"location":"conf/#list-of-directories-containing-templates","text":"OpenVeo uses Mustache as the template engine. Mustache requires directories where to look for potential templates. The list of directories is defined in conf.js : viewsFolders: [ // List of directories holding mustache templates [...] ]","title":"List of directories containing templates"},{"location":"conf/#define-image-styles","text":"You can define image styles in conf.js : imageProcessing: { folders: [ // List of folders which contain images to process on demand { imagesDirectory: 'example/images', // Path of the directory containing images to process relative to project root directory cacheDirectory: 'example/images/.cache' // Path of the directory containing processed images relative to project root directory (default to {imagesDirectory}/.cache) } ], styles: [ // The list of style definitions { id: 'book-style', // Id of the style to apply when requesting an image processing type: 'thumb', // The type of transformation to apply (only thumb is available right now) width: 200, // Expected width (in px) of the image (default to 10) quality: 50 // Expected quality from 0 to 100 (default to 90 with 100 the best) } } } Then you can call the image with your custom style book-style : img src= book/example/images/image1.jpg?style=book-style / Note that the original image is still available: img src= book/example/images/image1.jpg /","title":"Define image styles"},{"location":"conf/#define-custom-configuration","text":"You can define a custom configuration object in conf.js : custom: { customProperty1: 'customValue1', customProperty2: 2 } Nb: Custom configuration won't be interpreted but can be retrieved later using OpenVeo API. You can use it as you like.","title":"Define custom configuration"},{"location":"conf/#define-web-service-scopes","text":"You can define web service scopes in conf.js : webServiceScopes: [ { id: 'library-scopeId', name: 'Scope name', description: 'Scope description', paths: [ 'get /library/books/sell', 'get /library/books/buy' ] } ] A scope is defined by: an id which must be unique and prefix by the name of your plugin a name displayed in OpenVeo administration interface when listing scopes (it could be a translation id) a description not actually used (it could be a translation id) a list of rules this scope authorizes. In the above example, a client application with scope Scope name can perform requests on two endpoints: get /library/books/sell and get /library/books/buy . Both endpoints could have been grouped into one rule get /library/books/ . It is also possible to deal with paths containing dynamic parts like *get /library/books/25/sell using a rule with a parameter: get /library/books/:id/sell**","title":"Define web service scopes"},{"location":"end-to-end-tests/","text":"Introduction End to end tests are performed using Protractor and run from OpenVeo core . You first have to install and configure tests as described in core documentation . Write tests All end to end tests must be located in tests/client/e2eTests/ Suites must be described in tests/client/protractorSuites.json List of datas to create before launching tests must be available in tests/client/e2eTests/database/data.json","title":"End to end tests"},{"location":"end-to-end-tests/#introduction","text":"End to end tests are performed using Protractor and run from OpenVeo core . You first have to install and configure tests as described in core documentation .","title":"Introduction"},{"location":"end-to-end-tests/#write-tests","text":"All end to end tests must be located in tests/client/e2eTests/ Suites must be described in tests/client/protractorSuites.json List of datas to create before launching tests must be available in tests/client/e2eTests/database/data.json","title":"Write tests"},{"location":"getting-started/","text":"Generate a plugin OpenVeo Plugin Generator helps you creates a new OpenVeo plugin by generating the default plugin's structure. To generate a plugin, run the generator using: cd /WORKSPACE_PATH yo openveo-plugin You will be prompted for information. Don't worry if you made a mistake, nothing is immutable. At the end of the installation a new directory has been created containing the sources of your plugin. Your workspace should look like this: . \u251c\u2500\u2500 openveo-core \u251c\u2500\u2500 openveo-PLUGIN_NAME Link your plugin To easily install your plugin into OpenVeo core you need to make it a global NPM package using NPM links : cd /WORKSPACE_PATH/openveo-PLUGIN_NAME npm link Add @openveo/api to your plugin cd /WORKSPACE_PATH/openveo-PLUGIN_NAME npm link @openveo/api Build your plugin Plugin front end has to be built. cd /WORKSPACE_PATH/openveo-PLUGIN_NAME grunt prod Install your plugin Once a link has been made on your plugin you can install it using: cd /WORKSPACE_PATH/openveo-core npm link openveo-PLUGIN_NAME Start / Restart OpenVeo Your plugin is now created. You can start / restart OpenVeo: cd /WORKSPACE_PATH/openveo-core node server.js Verify that your plugin is working You can now access OpenVeo back end. From back end menu you should see a new entry with the name of your plugin. It should lead you to a TODO page. What's next? Now that you have a full operational plugin, you probably want to know more about it. The next pages will lead you to all you have to know about plugin's development.","title":"Getting started"},{"location":"getting-started/#generate-a-plugin","text":"OpenVeo Plugin Generator helps you creates a new OpenVeo plugin by generating the default plugin's structure. To generate a plugin, run the generator using: cd /WORKSPACE_PATH yo openveo-plugin You will be prompted for information. Don't worry if you made a mistake, nothing is immutable. At the end of the installation a new directory has been created containing the sources of your plugin. Your workspace should look like this: . \u251c\u2500\u2500 openveo-core \u251c\u2500\u2500 openveo-PLUGIN_NAME","title":"Generate a plugin"},{"location":"getting-started/#link-your-plugin","text":"To easily install your plugin into OpenVeo core you need to make it a global NPM package using NPM links : cd /WORKSPACE_PATH/openveo-PLUGIN_NAME npm link","title":"Link your plugin"},{"location":"getting-started/#add-openveoapi-to-your-plugin","text":"cd /WORKSPACE_PATH/openveo-PLUGIN_NAME npm link @openveo/api","title":"Add @openveo/api to your plugin"},{"location":"getting-started/#build-your-plugin","text":"Plugin front end has to be built. cd /WORKSPACE_PATH/openveo-PLUGIN_NAME grunt prod","title":"Build your plugin"},{"location":"getting-started/#install-your-plugin","text":"Once a link has been made on your plugin you can install it using: cd /WORKSPACE_PATH/openveo-core npm link openveo-PLUGIN_NAME","title":"Install your plugin"},{"location":"getting-started/#start-restart-openveo","text":"Your plugin is now created. You can start / restart OpenVeo: cd /WORKSPACE_PATH/openveo-core node server.js","title":"Start / Restart OpenVeo"},{"location":"getting-started/#verify-that-your-plugin-is-working","text":"You can now access OpenVeo back end. From back end menu you should see a new entry with the name of your plugin. It should lead you to a TODO page.","title":"Verify that your plugin is working"},{"location":"getting-started/#whats-next","text":"Now that you have a full operational plugin, you probably want to know more about it. The next pages will lead you to all you have to know about plugin's development.","title":"What's next?"},{"location":"hooks/","text":"Hooks OpenVeo core and plugins may define hooks which you can use to execute an action when a hook is called. Hooks on OpenVeo are more like events waiting for all actions to be complete. Hook actions are executed in the order of registration. Register an action to an existing hook To add an action to an existing hook do it in the init step of the plugin's life cycle : MyPlugin.prototype.init = function() { // First get the plugin API defining the hook you want to listen to var coreApi = process.api.getCoreApi(); // Get the list of hooks from the plugin var CORE_HOOKS = coreApi.getHooks(); // Register an action on a hook // CORE_HOOKS.ROLES_DELETED hook gives the list of deleted role ids as parameter and the // function to call when action is done coreApi.registerAction(CORE_HOOKS.ROLES_DELETED, function(ids, callback) { console.log(ids); console.log('Do something'); callback(); }); }; Create a hook for other plugins To create a hook which could be handled by other plugins do as follow: // Get the API of your plugin var api = process.api.getApi('my-plugin'); // Define data to send to actions var data = {}; // Execute all actions registered to the hook api.executeHook(api.getHooks().MY_CUSTOM_HOOK, data, function(error) { console.log('All actions of the hook done if no error'); });","title":"Hooks"},{"location":"hooks/#hooks","text":"OpenVeo core and plugins may define hooks which you can use to execute an action when a hook is called. Hooks on OpenVeo are more like events waiting for all actions to be complete. Hook actions are executed in the order of registration.","title":"Hooks"},{"location":"hooks/#register-an-action-to-an-existing-hook","text":"To add an action to an existing hook do it in the init step of the plugin's life cycle : MyPlugin.prototype.init = function() { // First get the plugin API defining the hook you want to listen to var coreApi = process.api.getCoreApi(); // Get the list of hooks from the plugin var CORE_HOOKS = coreApi.getHooks(); // Register an action on a hook // CORE_HOOKS.ROLES_DELETED hook gives the list of deleted role ids as parameter and the // function to call when action is done coreApi.registerAction(CORE_HOOKS.ROLES_DELETED, function(ids, callback) { console.log(ids); console.log('Do something'); callback(); }); };","title":"Register an action to an existing hook"},{"location":"hooks/#create-a-hook-for-other-plugins","text":"To create a hook which could be handled by other plugins do as follow: // Get the API of your plugin var api = process.api.getApi('my-plugin'); // Define data to send to actions var data = {}; // Execute all actions registered to the hook api.executeHook(api.getHooks().MY_CUSTOM_HOOK, data, function(error) { console.log('All actions of the hook done if no error'); });","title":"Create a hook for other plugins"},{"location":"i18n/","text":"Introduction Plugin translation dictionaries must be stored in i18n directory to be detected by the core. Translate back end pages To translate back end pages you'll need to add translations into admin-back-office dictionaries. Let's pretend we want to add a translation for a back end page of a library plugin. Add translation to dictionaries i18n/admin-back-office-en.json { BOOK : { BUY : Buy } } i18n/admin-back-office-fr.json { BOOK : { BUY : Acheter } } Use translation Then you can use the translate filter defined by the core (more information on OpenVeo core documentation ): label ng-bind= LIBRARY.BOOK.BUY | translate /label Note that the translation id is prefixed by the name of the plugin. Translate front end pages OpenVeo doesn't provide a particular way of developping the client side of front end pages. There is no JavaScript framework imposed. Thus you should use OpenVeo routes to get a particular dictionary. See OpenVeo core documentation for more information.","title":"I18N and I10N"},{"location":"i18n/#introduction","text":"Plugin translation dictionaries must be stored in i18n directory to be detected by the core.","title":"Introduction"},{"location":"i18n/#translate-back-end-pages","text":"To translate back end pages you'll need to add translations into admin-back-office dictionaries. Let's pretend we want to add a translation for a back end page of a library plugin.","title":"Translate back end pages"},{"location":"i18n/#add-translation-to-dictionaries","text":"i18n/admin-back-office-en.json { BOOK : { BUY : Buy } } i18n/admin-back-office-fr.json { BOOK : { BUY : Acheter } }","title":"Add translation to dictionaries"},{"location":"i18n/#use-translation","text":"Then you can use the translate filter defined by the core (more information on OpenVeo core documentation ): label ng-bind= LIBRARY.BOOK.BUY | translate /label Note that the translation id is prefixed by the name of the plugin.","title":"Use translation"},{"location":"i18n/#translate-front-end-pages","text":"OpenVeo doesn't provide a particular way of developping the client side of front end pages. There is no JavaScript framework imposed. Thus you should use OpenVeo routes to get a particular dictionary. See OpenVeo core documentation for more information.","title":"Translate front end pages"},{"location":"logger/","text":"Introduction All server logs are performed by module Winston . Use OpenVeo logger By default OpenVeo core creates one logger named openveo . You can use it directly: process.logger.silly('Silly log'); process.logger.debug('Debug log'); process.logger.verbose('Verbose log'); process.logger.info('Info log'); process.logger.warn('Warn log'); process.logger.error('Error log');","title":"Logger"},{"location":"logger/#introduction","text":"All server logs are performed by module Winston .","title":"Introduction"},{"location":"logger/#use-openveo-logger","text":"By default OpenVeo core creates one logger named openveo . You can use it directly: process.logger.silly('Silly log'); process.logger.debug('Debug log'); process.logger.verbose('Verbose log'); process.logger.info('Info log'); process.logger.warn('Warn log'); process.logger.error('Error log');","title":"Use OpenVeo logger"},{"location":"plugin-life-cycle/","text":"Plugin's life cycle When starting the OpenVeo process, the core will automatically execute methods of plugins in the following order: init When called, core API is available, connection to database has been established, plugins are loaded and migrations scripts have been executed. This is a good place to create database indexes for all providers of the plugin and do some init stuff start When called, init steps have been performed on all plugins","title":"Plugin life cycle"},{"location":"plugin-life-cycle/#plugins-life-cycle","text":"When starting the OpenVeo process, the core will automatically execute methods of plugins in the following order: init When called, core API is available, connection to database has been established, plugins are loaded and migrations scripts have been executed. This is a good place to create database indexes for all providers of the plugin and do some init stuff start When called, init steps have been performed on all plugins","title":"Plugin's life cycle"},{"location":"prerequisites/","text":"OpenVeo Plugin Generator requires: Yeoman - The OpenVeo Plugin Generator is a Yeoman plugin OpenVeo - Generated plugins needs OpenVeo Core in development environment","title":"Prerequisites"},{"location":"structure/","text":"Structure When generated, the plugin's structure should look like: . \u251c\u2500\u2500 app // Project's sources \u2502 \u251c\u2500\u2500 client // Client side sources (executed in a browser) \u2502 \u2502 \u251c\u2500\u2500 admin // Client side sources for the back end pages \u2502 \u2502 \u2502 \u251c\u2500\u2500 compass // SCSS files of the back end pages \u2502 \u2502 \u2502 \u2514\u2500\u2500 js // JavaScript files of the back end pages \u2502 \u2502 \u2502 \u2514\u2500\u2500 ovPluginName // All JavaScript files of the plugin's AngularJS module \u2502 \u2502 \u2514\u2500\u2500 front // Client side sources for front end pages \u2502 \u2514\u2500\u2500 server // Server side sources (executed by Node.js) \u2502 \u251c\u2500\u2500 controllers // Controllers (extending Controller) \u2502 \u2502 \u2514\u2500\u2500 httpErrors.js // Holds the list of HTTP errors used by controllers \u2502 \u251c\u2500\u2500 providers // Providers (extending Provider) \u2502 \u251c\u2500\u2500 PLUGIN_NAMEPlugin.js // The plugin class (extending Plugin) \u2502 \u2514\u2500\u2500 PLUGIN_NAMEPluginApi.js // The pluginApi class (extending PluginApi) \u251c\u2500\u2500 assets // Public directory for static files (mounted on /PLUGIN_NAME/) \u2502 \u2514\u2500\u2500 be // Back end pages resources \u2502 \u251c\u2500\u2500 css // Generated CSS files for the back end pages \u2502 \u251c\u2500\u2500 js // Generated JavaScript files for the back end pages \u2502 \u2514\u2500\u2500 views // AngularJS partials for the back end pages \u251c\u2500\u2500 docs // Markdown documentation of the project \u251c\u2500\u2500 i18n // Translation dictionaries \u251c\u2500\u2500 migrations // Migration scripts \u251c\u2500\u2500 tasks // Grunt tasks \u251c\u2500\u2500 tests // Tests \u2502 \u251c\u2500\u2500 client // Client side tests \u2502 \u2502 \u251c\u2500\u2500 unitTests // Unit tests \u2502 \u2502 \u2514\u2500\u2500 e2eTests // End to end tests using protractor \u2502 \u2514\u2500\u2500 server // Server side unit tests \u251c\u2500\u2500 .eslintrc // Eslint rules \u251c\u2500\u2500 .gitattributes // Git attributes configuration file \u251c\u2500\u2500 .npmignore // NPM ignore configuration file \u251c\u2500\u2500 CHANGELOG.md // Plugin's change logs \u251c\u2500\u2500 Gruntfile.js // Grunt configuration file \u251c\u2500\u2500 README.md // Plugin's README \u251c\u2500\u2500 conf.js // Plugin's configuration file \u251c\u2500\u2500 index.js // Plugin's main file \u251c\u2500\u2500 mkdocs.yml // MkDocs configuration file \u2514\u2500\u2500 package.json // NPM configuration file Dive into plugin's files Plugin's directory After executing the plugin's generator a directory openveo-PLUGIN_NAME should be available in your workspace. Plugin's main files index.js exposes: The Plugin class. If this class does not extend the Plugin class, defined in module @openveo/api , the plugin won't be loaded by the core. processRequire.js defines: A process.rootPLUGIN_NAME property holding the absolute path of the plugin's root directory which you can use everywhere in your plugin A process.requirePLUGIN_NAME property holding a function to require a Node.js module using a path relative to the plugin's root path. As the root of the application is the core directory using Node.js require function will load a module from the core root directory. Best practice is to use relative path to require a module in your plugin or use the function process.requirePLUGIN_NAME with a path relative to the root of your plugin. Plugin class A plugin must have a class which extends Plugin class (defined in module @openveo/api ). Locate file app/server/PLUGIN_NAMEPlugin.js . PLUGIN_NAMEPlugin.js extends Plugin class and has the following properties: router The express HTTP router holding all public routes of the plugin privateRouter The express HTTP router holding all private routes of the plugin (require a back end authentication) webServiceRouter The express HTTP router holding all Web Service routes of the plugin (require Web Service authentication) api The API exposed, by the plugin, to other plugins (must be an instance of PluginApi ) init A method part of the plugin's life cycle , automatically called by the core before starting the servers start A method part of the plugin's life cycle , automatically called by the core after the init step All these properties are optional. Plugin API A plugin can expose APIs to other plugins by creating a class extending the PluginApi class. Locate file app/server/PLUGIN_NAMEPluginApi.js . PLUGIN_NAMEPluginApi.js extends PluginApi . All methods and properties will be exposed to other plugins through the api property of the Plugin. Resources All files inside assets directory are served by the HTTP server as they are. You can put here images, front JavaScript files, CSS files and so on. The core will mount this directory on /PLUGIN_NAME/ , thus to access image assets/test.jpg you have to call /PLUGIN_NAME/test.jpg .","title":"Plugin structure"},{"location":"structure/#structure","text":"When generated, the plugin's structure should look like: . \u251c\u2500\u2500 app // Project's sources \u2502 \u251c\u2500\u2500 client // Client side sources (executed in a browser) \u2502 \u2502 \u251c\u2500\u2500 admin // Client side sources for the back end pages \u2502 \u2502 \u2502 \u251c\u2500\u2500 compass // SCSS files of the back end pages \u2502 \u2502 \u2502 \u2514\u2500\u2500 js // JavaScript files of the back end pages \u2502 \u2502 \u2502 \u2514\u2500\u2500 ovPluginName // All JavaScript files of the plugin's AngularJS module \u2502 \u2502 \u2514\u2500\u2500 front // Client side sources for front end pages \u2502 \u2514\u2500\u2500 server // Server side sources (executed by Node.js) \u2502 \u251c\u2500\u2500 controllers // Controllers (extending Controller) \u2502 \u2502 \u2514\u2500\u2500 httpErrors.js // Holds the list of HTTP errors used by controllers \u2502 \u251c\u2500\u2500 providers // Providers (extending Provider) \u2502 \u251c\u2500\u2500 PLUGIN_NAMEPlugin.js // The plugin class (extending Plugin) \u2502 \u2514\u2500\u2500 PLUGIN_NAMEPluginApi.js // The pluginApi class (extending PluginApi) \u251c\u2500\u2500 assets // Public directory for static files (mounted on /PLUGIN_NAME/) \u2502 \u2514\u2500\u2500 be // Back end pages resources \u2502 \u251c\u2500\u2500 css // Generated CSS files for the back end pages \u2502 \u251c\u2500\u2500 js // Generated JavaScript files for the back end pages \u2502 \u2514\u2500\u2500 views // AngularJS partials for the back end pages \u251c\u2500\u2500 docs // Markdown documentation of the project \u251c\u2500\u2500 i18n // Translation dictionaries \u251c\u2500\u2500 migrations // Migration scripts \u251c\u2500\u2500 tasks // Grunt tasks \u251c\u2500\u2500 tests // Tests \u2502 \u251c\u2500\u2500 client // Client side tests \u2502 \u2502 \u251c\u2500\u2500 unitTests // Unit tests \u2502 \u2502 \u2514\u2500\u2500 e2eTests // End to end tests using protractor \u2502 \u2514\u2500\u2500 server // Server side unit tests \u251c\u2500\u2500 .eslintrc // Eslint rules \u251c\u2500\u2500 .gitattributes // Git attributes configuration file \u251c\u2500\u2500 .npmignore // NPM ignore configuration file \u251c\u2500\u2500 CHANGELOG.md // Plugin's change logs \u251c\u2500\u2500 Gruntfile.js // Grunt configuration file \u251c\u2500\u2500 README.md // Plugin's README \u251c\u2500\u2500 conf.js // Plugin's configuration file \u251c\u2500\u2500 index.js // Plugin's main file \u251c\u2500\u2500 mkdocs.yml // MkDocs configuration file \u2514\u2500\u2500 package.json // NPM configuration file","title":"Structure"},{"location":"structure/#dive-into-plugins-files","text":"","title":"Dive into plugin's files"},{"location":"structure/#plugins-directory","text":"After executing the plugin's generator a directory openveo-PLUGIN_NAME should be available in your workspace.","title":"Plugin's directory"},{"location":"structure/#plugins-main-files","text":"index.js exposes: The Plugin class. If this class does not extend the Plugin class, defined in module @openveo/api , the plugin won't be loaded by the core. processRequire.js defines: A process.rootPLUGIN_NAME property holding the absolute path of the plugin's root directory which you can use everywhere in your plugin A process.requirePLUGIN_NAME property holding a function to require a Node.js module using a path relative to the plugin's root path. As the root of the application is the core directory using Node.js require function will load a module from the core root directory. Best practice is to use relative path to require a module in your plugin or use the function process.requirePLUGIN_NAME with a path relative to the root of your plugin.","title":"Plugin's main files"},{"location":"structure/#plugin-class","text":"A plugin must have a class which extends Plugin class (defined in module @openveo/api ). Locate file app/server/PLUGIN_NAMEPlugin.js . PLUGIN_NAMEPlugin.js extends Plugin class and has the following properties: router The express HTTP router holding all public routes of the plugin privateRouter The express HTTP router holding all private routes of the plugin (require a back end authentication) webServiceRouter The express HTTP router holding all Web Service routes of the plugin (require Web Service authentication) api The API exposed, by the plugin, to other plugins (must be an instance of PluginApi ) init A method part of the plugin's life cycle , automatically called by the core before starting the servers start A method part of the plugin's life cycle , automatically called by the core after the init step All these properties are optional.","title":"Plugin class"},{"location":"structure/#plugin-api","text":"A plugin can expose APIs to other plugins by creating a class extending the PluginApi class. Locate file app/server/PLUGIN_NAMEPluginApi.js . PLUGIN_NAMEPluginApi.js extends PluginApi . All methods and properties will be exposed to other plugins through the api property of the Plugin.","title":"Plugin API"},{"location":"structure/#resources","text":"All files inside assets directory are served by the HTTP server as they are. You can put here images, front JavaScript files, CSS files and so on. The core will mount this directory on /PLUGIN_NAME/ , thus to access image assets/test.jpg you have to call /PLUGIN_NAME/test.jpg .","title":"Resources"},{"location":"template-engine/","text":"OpenVeo uses Mustache as the template engine. You have to declare a directory containing your template files before using a mustache template file. You can do it in conf.js file. Then you can call the template using render express function in your controller's actions.","title":"Template engine"},{"location":"tutorial/","text":"Introduction Let's pretend we want to create a plugin called library to manage a list of books. Create the plugin Create the plugin using the Yeoman generator. Name it library . yo openveo-plugin library Restart server Each time you modify a plugin conf.js or server sources, you need to restart your server to load your changes. Best practice in developpement is to use a source watcher to reload automatically your server each time you save a file. You can use Nodemon or PM2 ENTITY Create an entity Let's pretend we want to create an entity called books . An entity is a content with built-in CRUD (Create Read Update Delete) operations. Declare the entity From the root of the library plugin locate the file conf.js and defines a new entity books : entities: { books: 'app/server/controllers/BooksController' } That's all for the conf.js file. Note that no routes and no permissions need to be created. OpenVeo will create the following HTTP routes for you: Private HTTP routes : get /be/library/books/:id - Get a particular book get /be/library/books - Get all books post /be/library/books/:id - Update a particular book put /be/library/books - Add a new book delete /be/library/books/:id - Delete a book Web Service end points : get /library/books/:id - Get a particular book get /library/books - Get all books post /library/books/:id - Update a particular book put /library/books - Add a new book delete /library/books/:id - Delete a book OpenVeo will also automatically create the following permissions: LIBRARY.PERMISSIONS.GROUP_BOOKS LIBRARY.PERMISSIONS.ADD_BOOKS_NAME LIBRARY.PERMISSIONS.UPDATE_BOOKS_NAME LIBRARY.PERMISSIONS.DELETE_BOOKS_NAME An entity must be associated to a controller and a provider. Let's create them. Create entity controller Create file app/server/controllers/BooksController.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); var BooksProvider = process.requireLibrary('app/server/providers/BooksProvider.js'); /** * Creates a BooksController. */ function BooksController(database) { BooksController.super_.call(this); } module.exports = BooksController; util.inherits(BooksController, openVeoApi.controllers.EntityController); /** * Gets an instance of the BooksProvider. * * @method getProvider * @return {BooksProvider} The BooksProvider instance */ BooksController.prototype.getProvider = function() { var database = process.api.getCoreApi().getDatabase(); return new BooksProvider(database); }; // You should consider overriding the following methods from EntityController: // BooksController.prototype.getEntitiesAction // BooksController.prototype.getEntityAction // BooksController.prototype.updateEntityAction // BooksController.prototype.addEntitiesAction // BooksController.prototype.removeEntitiesAction A controller associated to an entity must inherits from EntityController and implements the getProvider method. All routes actions are handled by the EntityController. However it is recommended to override these actions to control incoming request parameters. Create entity provider Create file app/server/providers/BooksProvider.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); /** * Creates a BooksProvider. */ function BooksProvider(database) { BooksProvider.super_.call(this, database, 'library_books'); } // BookProvider must extend EntityProvider module.exports = BooksProvider; util.inherits(BooksProvider, openVeoApi.providers.EntityProvider); A provider associated to an entity must inherits from EntityProvider . EntityProvider provides methods to interact with the storage to manipulate the entity (CRUD). The EntityProvider expects the database instance as the first parameter. You can get the current database instance using: var database = process.api.getCoreApi().getDatabase(); EntityProvider expects, as second parameter, the name of the database collection to use for your entity. A best practice is to prefix the collection by the name of the plugin. PUBLIC PAGES Create a public page to display a book Let's pretend we want to add a public page to display information about a book. Add the HTTP route to display the book From the root of the library plugin locate the file conf.js . module.exports = { http: { routes: { public: { 'get /books/:id/read': 'app/server/controllers/BooksController.displayBookAction' } } } }; Requesting /library/books/1/read will call the displayBookAction method of the BooksController . As a reminder: public HTTP routes will be mounted on /library/ private HTTP routes will be mounted on /be/library/ web service routes will be mounted on /library/ (on Web Service's server) Create the route action Public route /library/books/:id/read has been configured to call the displayBookAction method of the BooksController . Let's create the displayBookAction method. Open the app/server/controllers/BooksController.js and add the following code at the end of the file: /** * Displays a book. */ BooksController.prototype.displayBookAction = function(request, response, next) { var params = null; // Validate request parameters try { params = openVeoApi.util.shallowValidateObject(request.params, { id: {type: 'string', required: true} }); } catch (error) { return next({ code: 0x001, httpCode: 400, module: 'book' }); } // Retrieve book var booksProvider = this.getProvider(); booksProvider.getOne(new ResourceFilter().equal('id', params.id), null, function(error, book) { // Display template book.html (created on the next step) using Mustache template response.render('book', book); }); }; For now our public route /library/books/:id/read isn't working because the displayBookAction method renders a template called book.html which is not created yet. Let's create it. Create the view Create a file app/client/front/views/book.html : !DOCTYPE html html body div h1 {{title}} /h1 p {{summary}} /p /div /body /html For now our public route is still not working because Mustache template engine doesn't know where to find templates. Let's tell him. Set template's directory Add the app/client/front/views directory to the list of directories handled by Mustache template engine (in conf.js file): viewsFolders: [ 'app/client/front/views' ] You can now restart OpenVeo and navigate to /library/books/1/read to display the book of id 1 . BACK END PAGES Create a back end page to display book information Let's pretend we want to add a private page (back end page) to display information about a book. Configure back end menu As described in conf.js documentation you can add a page to the back end. Open conf.js file and add a new back end page. backOffice: { menu: [ { weight: -50, label: 'LIBRARY.MENU.LIBRARY', subMenu: [ { label: 'LIBRARY.MENU.BOOK', path: 'library/bookInfo', permission: 'library-access-book-page' } ] } ] } We defined a new menu entry for our plugin with label LIBRARY.MENU.LIBRARY (translation id) and a sub menu with one item named LIBRARY.MENU.BOOK (translation id) which requires library-access-book-page permission to see the page. For now there is nothing being the AngularJS route library/bookInfo . Let's create the route. Add an AngularJS back end route As OpenVeo back end is written in AngularJS, each plugin has an AngularJS module to create its back end pages. From the root of the library plugin locate the file app/client/admin/js/ovLibrary/BookApp.js . You can see the AngularJS module corresponding to the plugin. Add the new route: // Add route /library/bookInfo $routeProvider.when('/library/bookInfo', { templateUrl: '/library/be/views/bookInfo.html', controller: 'LibraryBookController', title: 'LIBRARY.BOOK.PAGE_TITLE', access: 'library-access-book-page', resolve: { book: ['$q', function($q) { var p = $q.defer(); p.resolve({ title: 'Journey to the center of the earth', summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson ( Heimskringla ; the chronicle of the Norwegian kings who ruled over Iceland).' }); return p.promise; }] } }); We defined a new route /library/bookInfo with a template, a controller, a page title and a permission to access the page. Let's create the controller, the template and the title translation. Add back end page controller Create a file app/client/admin/js/ovLibrary/BookController.js : 'use strict'; (function(app) { /** * Defines a book controller. */ function BookController($scope, book) { $scope.title = book.title; $scope.summary = book.summary; } app.controller('LibraryBookController', BookController); BookController.$inject = ['$scope', 'book']; })(angular.module('ov.library')); Open conf.js file and add the newly created file to the list of files to be loaded by OpenVeo: backOffice: { scriptFiles: { base: [], dev: [ 'ovLibrary/BookController.js' ] } } Add back end page template Create a file assert/be/views/bookInfo.html : h1 ng-bind= title /h1 p ng-bind= summary /p Add back end translations You can translate your back end pages using the back end dictionary called admin-back-office . Core will search for an i18n directory to look for dictionaries. From the root of the library plugin locate the i18n directory. You can see french and english dictionaries for the back end ( i18n/admin-back-office-en.json and i18n/admin-back-office-fr.json ). Add new translations in all languages ( i18n/admin-back-office-en.json , i18n/admin-back-office-fr.json etc.): { MENU : { LIBRARY : Library , BOOK : Book }, BOOK : { PAGE_TITLE : My book page } } Nb : For more information on internationalization please refer to the i18n documentation .","title":"Tutorial"},{"location":"tutorial/#introduction","text":"Let's pretend we want to create a plugin called library to manage a list of books.","title":"Introduction"},{"location":"tutorial/#create-the-plugin","text":"Create the plugin using the Yeoman generator. Name it library . yo openveo-plugin library","title":"Create the plugin"},{"location":"tutorial/#restart-server","text":"Each time you modify a plugin conf.js or server sources, you need to restart your server to load your changes. Best practice in developpement is to use a source watcher to reload automatically your server each time you save a file. You can use Nodemon or PM2","title":"Restart server"},{"location":"tutorial/#entity","text":"","title":"ENTITY"},{"location":"tutorial/#create-an-entity","text":"Let's pretend we want to create an entity called books . An entity is a content with built-in CRUD (Create Read Update Delete) operations.","title":"Create an entity"},{"location":"tutorial/#declare-the-entity","text":"From the root of the library plugin locate the file conf.js and defines a new entity books : entities: { books: 'app/server/controllers/BooksController' } That's all for the conf.js file. Note that no routes and no permissions need to be created. OpenVeo will create the following HTTP routes for you: Private HTTP routes : get /be/library/books/:id - Get a particular book get /be/library/books - Get all books post /be/library/books/:id - Update a particular book put /be/library/books - Add a new book delete /be/library/books/:id - Delete a book Web Service end points : get /library/books/:id - Get a particular book get /library/books - Get all books post /library/books/:id - Update a particular book put /library/books - Add a new book delete /library/books/:id - Delete a book OpenVeo will also automatically create the following permissions: LIBRARY.PERMISSIONS.GROUP_BOOKS LIBRARY.PERMISSIONS.ADD_BOOKS_NAME LIBRARY.PERMISSIONS.UPDATE_BOOKS_NAME LIBRARY.PERMISSIONS.DELETE_BOOKS_NAME An entity must be associated to a controller and a provider. Let's create them.","title":"Declare the entity"},{"location":"tutorial/#create-entity-controller","text":"Create file app/server/controllers/BooksController.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); var BooksProvider = process.requireLibrary('app/server/providers/BooksProvider.js'); /** * Creates a BooksController. */ function BooksController(database) { BooksController.super_.call(this); } module.exports = BooksController; util.inherits(BooksController, openVeoApi.controllers.EntityController); /** * Gets an instance of the BooksProvider. * * @method getProvider * @return {BooksProvider} The BooksProvider instance */ BooksController.prototype.getProvider = function() { var database = process.api.getCoreApi().getDatabase(); return new BooksProvider(database); }; // You should consider overriding the following methods from EntityController: // BooksController.prototype.getEntitiesAction // BooksController.prototype.getEntityAction // BooksController.prototype.updateEntityAction // BooksController.prototype.addEntitiesAction // BooksController.prototype.removeEntitiesAction A controller associated to an entity must inherits from EntityController and implements the getProvider method. All routes actions are handled by the EntityController. However it is recommended to override these actions to control incoming request parameters.","title":"Create entity controller"},{"location":"tutorial/#create-entity-provider","text":"Create file app/server/providers/BooksProvider.js : 'use strict'; var util = require('util'); var openVeoApi = require('@openveo/api'); /** * Creates a BooksProvider. */ function BooksProvider(database) { BooksProvider.super_.call(this, database, 'library_books'); } // BookProvider must extend EntityProvider module.exports = BooksProvider; util.inherits(BooksProvider, openVeoApi.providers.EntityProvider); A provider associated to an entity must inherits from EntityProvider . EntityProvider provides methods to interact with the storage to manipulate the entity (CRUD). The EntityProvider expects the database instance as the first parameter. You can get the current database instance using: var database = process.api.getCoreApi().getDatabase(); EntityProvider expects, as second parameter, the name of the database collection to use for your entity. A best practice is to prefix the collection by the name of the plugin.","title":"Create entity provider"},{"location":"tutorial/#public-pages","text":"","title":"PUBLIC PAGES"},{"location":"tutorial/#create-a-public-page-to-display-a-book","text":"Let's pretend we want to add a public page to display information about a book.","title":"Create a public page to display a book"},{"location":"tutorial/#add-the-http-route-to-display-the-book","text":"From the root of the library plugin locate the file conf.js . module.exports = { http: { routes: { public: { 'get /books/:id/read': 'app/server/controllers/BooksController.displayBookAction' } } } }; Requesting /library/books/1/read will call the displayBookAction method of the BooksController . As a reminder: public HTTP routes will be mounted on /library/ private HTTP routes will be mounted on /be/library/ web service routes will be mounted on /library/ (on Web Service's server)","title":"Add the HTTP route to display the book"},{"location":"tutorial/#create-the-route-action","text":"Public route /library/books/:id/read has been configured to call the displayBookAction method of the BooksController . Let's create the displayBookAction method. Open the app/server/controllers/BooksController.js and add the following code at the end of the file: /** * Displays a book. */ BooksController.prototype.displayBookAction = function(request, response, next) { var params = null; // Validate request parameters try { params = openVeoApi.util.shallowValidateObject(request.params, { id: {type: 'string', required: true} }); } catch (error) { return next({ code: 0x001, httpCode: 400, module: 'book' }); } // Retrieve book var booksProvider = this.getProvider(); booksProvider.getOne(new ResourceFilter().equal('id', params.id), null, function(error, book) { // Display template book.html (created on the next step) using Mustache template response.render('book', book); }); }; For now our public route /library/books/:id/read isn't working because the displayBookAction method renders a template called book.html which is not created yet. Let's create it.","title":"Create the route action"},{"location":"tutorial/#create-the-view","text":"Create a file app/client/front/views/book.html : !DOCTYPE html html body div h1 {{title}} /h1 p {{summary}} /p /div /body /html For now our public route is still not working because Mustache template engine doesn't know where to find templates. Let's tell him.","title":"Create the view"},{"location":"tutorial/#set-templates-directory","text":"Add the app/client/front/views directory to the list of directories handled by Mustache template engine (in conf.js file): viewsFolders: [ 'app/client/front/views' ] You can now restart OpenVeo and navigate to /library/books/1/read to display the book of id 1 .","title":"Set template's directory"},{"location":"tutorial/#back-end-pages","text":"","title":"BACK END PAGES"},{"location":"tutorial/#create-a-back-end-page-to-display-book-information","text":"Let's pretend we want to add a private page (back end page) to display information about a book.","title":"Create a back end page to display book information"},{"location":"tutorial/#configure-back-end-menu","text":"As described in conf.js documentation you can add a page to the back end. Open conf.js file and add a new back end page. backOffice: { menu: [ { weight: -50, label: 'LIBRARY.MENU.LIBRARY', subMenu: [ { label: 'LIBRARY.MENU.BOOK', path: 'library/bookInfo', permission: 'library-access-book-page' } ] } ] } We defined a new menu entry for our plugin with label LIBRARY.MENU.LIBRARY (translation id) and a sub menu with one item named LIBRARY.MENU.BOOK (translation id) which requires library-access-book-page permission to see the page. For now there is nothing being the AngularJS route library/bookInfo . Let's create the route.","title":"Configure back end menu"},{"location":"tutorial/#add-an-angularjs-back-end-route","text":"As OpenVeo back end is written in AngularJS, each plugin has an AngularJS module to create its back end pages. From the root of the library plugin locate the file app/client/admin/js/ovLibrary/BookApp.js . You can see the AngularJS module corresponding to the plugin. Add the new route: // Add route /library/bookInfo $routeProvider.when('/library/bookInfo', { templateUrl: '/library/be/views/bookInfo.html', controller: 'LibraryBookController', title: 'LIBRARY.BOOK.PAGE_TITLE', access: 'library-access-book-page', resolve: { book: ['$q', function($q) { var p = $q.defer(); p.resolve({ title: 'Journey to the center of the earth', summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson ( Heimskringla ; the chronicle of the Norwegian kings who ruled over Iceland).' }); return p.promise; }] } }); We defined a new route /library/bookInfo with a template, a controller, a page title and a permission to access the page. Let's create the controller, the template and the title translation.","title":"Add an AngularJS back end route"},{"location":"tutorial/#add-back-end-page-controller","text":"Create a file app/client/admin/js/ovLibrary/BookController.js : 'use strict'; (function(app) { /** * Defines a book controller. */ function BookController($scope, book) { $scope.title = book.title; $scope.summary = book.summary; } app.controller('LibraryBookController', BookController); BookController.$inject = ['$scope', 'book']; })(angular.module('ov.library')); Open conf.js file and add the newly created file to the list of files to be loaded by OpenVeo: backOffice: { scriptFiles: { base: [], dev: [ 'ovLibrary/BookController.js' ] } }","title":"Add back end page controller"},{"location":"tutorial/#add-back-end-page-template","text":"Create a file assert/be/views/bookInfo.html : h1 ng-bind= title /h1 p ng-bind= summary /p","title":"Add back end page template"},{"location":"tutorial/#add-back-end-translations","text":"You can translate your back end pages using the back end dictionary called admin-back-office . Core will search for an i18n directory to look for dictionaries. From the root of the library plugin locate the i18n directory. You can see french and english dictionaries for the back end ( i18n/admin-back-office-en.json and i18n/admin-back-office-fr.json ). Add new translations in all languages ( i18n/admin-back-office-en.json , i18n/admin-back-office-fr.json etc.): { MENU : { LIBRARY : Library , BOOK : Book }, BOOK : { PAGE_TITLE : My book page } } Nb : For more information on internationalization please refer to the i18n documentation .","title":"Add back end translations"},{"location":"unit-tests/","text":"Node.js unit tests Server side unit tests are performed using Mocha and Chai . You can launch server unit tests with the following command: grunt mochaTest AngularJS unit tests Client side unit tests are performed using Karma . You can launch client unit tests with the following command: grunt karma","title":"Unit tests"},{"location":"unit-tests/#nodejs-unit-tests","text":"Server side unit tests are performed using Mocha and Chai . You can launch server unit tests with the following command: grunt mochaTest","title":"Node.js unit tests"},{"location":"unit-tests/#angularjs-unit-tests","text":"Client side unit tests are performed using Karma . You can launch client unit tests with the following command: grunt karma","title":"AngularJS unit tests"}]}